\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\let\oldAuthor\author
\renewcommand{\author}[1]{\newcommand{\myAuthor}{#1}\oldAuthor{#1}} 
\usepackage{listings}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage[nolist]{acronym}
\setlist[description]{leftmargin=0.4cm}
\usepackage{graphicx}
\usepackage{hyperref}

\begin{document}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}
\lstset{style=CStyle}

%---------------------------------------------------------
%Fill in:
%1. Title of lab. 
%2. Student names and corresponding Email addresses. If many separate 
%---------------------------------------------------------
\title{Operating Systems - Assignment 2}
\author{Ansgar Lemke (ansgar.lemke@stud-mail.uni-wuerzburg.de, ens21ale)}
\date{} %<-- LEAVE EMPTY! 
\begin{titlepage}
\maketitle 
%---------------------------------------------------------
%Fill in:
%1. Course name
%2. Supervisor name(s), if many separate them by comma.
%---------------------------------------------------------
\thispagestyle{fancy}
\headheight 35pt 
\lhead{\small Department of Computing Science \\ Ume\aa\ University}
\rhead{\small\today}
\cfoot{Operating Systems \\ Supervisor: Monowar Bhuyan (monowar@cs.umu.se),\\ Sourasekhar Banerjee (sourasb@cs.umu.se)}
\begin{abstract}
%	What was the aim of the experiment? 
A simple scatter-gather functionality will be implemented.
%	What was measured?
The execution speed of the implementation will be compared using different parameters for the scatter-gather function calls to compute the same problem.
%	Which techniques/methods were used? 
This approach uses shared memory and processes to implement the functionality.
%	What are the main results?
Depending on the size of memory, used devices and the computational load of the tasks, there is an optimal number of processes to use.

\end{abstract}

\end{titlepage}
\pagestyle{fancy}
\headheight 35pt 
\rhead{\small\today}
\lhead{\myAuthor}
\cfoot{\thepage}

\section{Description}

scatter-gather is an algorithm to split up a memory area so that multiple processes can work on the same computational problem and combine the results to one field of memory afterwards. MPI implements this functionality as MPI\_Scatter\_Gather, however, this solution aims to be as easy to use as possible. It's only dependencies are standard libraries.

\subsection{Solution}

The library is implemented in C99 which makes it available to many applications. With the used of shared memory but separated areas within for the different processes, questions of synchronization fall apart in most of the implementation. In the scattered phase, the processes work independent of each other and do not need any synchronization or communication which offers a good concurrent environment. 

\subsection{Design Decisions}

Each process is assigned to a segment which corresponds to a certain area of the shared memory. The highest segment is assigned to the parent process. This information can be used to exit all other processes in the end to continue on the parent only. 

One goal is to provide an interface to the user which grants full functionality while being relatively safe by hiding parts that are not relevant for end users. There are two functions available to be used by the user:

\begin{itemize}
    \item {scatter takes the data where the processes should work on (init\_data), the number of processes (segments) to create, a pointer to the memory for each process (proc\_data) and the length of the whole data in bytes. It returns the number of children of each process or -1 in case of error. It is highly recommended to check for the return value to proceed, more information might be found at errno. \\
    scatter creates an area of shared memory and copies init\_data into this area. Then, child processes will be created recursively until there are as many as wanted by the user. Each of them will be assigned a location in shared memory to work on. }
    \item {gather takes only one argument, a pointer where to write the combined work of the processes (exit\_data). If gather works fine, it returns 0, otherwise the number of processes that have not finished from what reason ever. For example, when gather is called a second time. \\
    Processes without children can exit immidiatly while those with children need to wait for them to exit. The root process will not exit but return in the end.}
\end{itemize}

To transmit data from scatter to gather, internally a static struct is used. It contains the following values

\begin{itemize}
    \item com - the shared memory
    \item length - size of shared memory in bytes
    \item segments - number of parallel processes
    \item is\_root - whether this is the process that the user has created
    \item children - number of children of the current process
    \item used - a state variable to prevent nested scatter/gather calls
\end{itemize}

This might not be the optimal solution but a smaller number of state variables might lead to more programming mistakes.

The above mentioned pointer to the memory for each process points to a location inside the shared memory so some memcpy calls can be avoided. In the end of gather, the content of the shared memory is being copied back to exit\_data so that no shared memory exists after gather has finished. 

\subsection{Assumptions}

The spawned processes must only work on their own memory section, proc\_memory. They must not change the location of the pointer because then their changes will not be written back. They must strictly remain inside their memory area, otherwise they would write either on memory of another process or even to an invalid location outside the shared memory area.  

init\_data must always be initialized while the other pointers should not, but may be as well (causing memory leaks).

It is assumed that all processes take nearly the same amount of time, otherwise, the waiting might take up to the time the slowest process needs to finish plus the time to exit the others.

It is assumed that processes do enough work to justify the overhead by process creation and destruction.

The user must check for return values because pointers might be invalid in case of error. This leads to segmentation faults and should be avoided.


\subsection{Limitations}

The amount of available data types is restricted to the basic C types which do not contain any pointers to other memory locations and have a fixed size, e. g. int, char. Inclusion of pointers or other more complex data structures would introduce the problem that these need to be copied to the shared memory as well while it is not known how exactly their structure looks like.

The scatter-gather calls cannot be nested, if scatter is called, gather must follow exactly one time. This greatly simplifies the structure because a lot of the functionality can be hidden from the user. 

Of course, there is a maximum size of memory that can be used in RAM.

On multi-processor systems, the behavior of cache pages might reduce performance when data needs to be copied back again or adjacent memory areas might be synchronized as well out of the interpretation that most users might want to access these as well. The effects of false sharing might also decrease the execution speed.

\section{Examples}

To demonstrate the functionality of scatter-gather, two computational problems will be executed with different amounts of processes. 

\subsection{Arithmetic Operations}
On each segment of memory, a combination of set, scale, add, scale is executed a hundred times. 

\subsection{Generating Random Numbers}
The segment of process memory is being filled with random numbers one time.

\bibliographystyle{plain}

\begin{thebibliography}{99}
	\bibitem{sched_plot_thickens} Corbet, Jonathan, Schedulers: The Plot Thickens, LWN.net, (April 2007, \href{https://lwn.net/Articles/230574/}{https://lwn.net/Articles/230574/}).
	\bibitem{mp_sched} sched(7) Linux User's Manual, Edition 5.3, (February 2022).
    \bibitem{async} oxnz: Linux Asynchronous I/O (October 13 2016, https://oxnz.github.io/2016/10/13/linux-aio/).
    \bibitem{nocache} open(2) Linux User's Manual, Edition 5.13, (February 2022).
    \bibitem{iosched} colin-king et al: IOSchedulers ubuntu wiki (September 2019, https://wiki.ubuntu.com/Kernel/Reference/IOSchedulers).
\end{thebibliography}

\end{document}
